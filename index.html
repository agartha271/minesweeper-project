<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minesweeper ‚Äî Modern</title>
  <style>
    :root{
      --bg:#f4f4f4; --panel:#fff; --accent:#0b57c6; --face:#ffd84d; --text:#000;
      --tile:#e9e9e9; --tile-down:#dcdcdc; --tile-border:#c7c7c7;
      --flag:#ff5050; --shadow:rgba(0,0,0,0.12);
      --cell-size:44px;
    }
    .dark {
      --bg: #0e1a2b;
      --panel: #172a45;
      --accent: #3a82f7;
      --face: #ffc947;
      --text: #d1d9ff;
      --tile: #203556;
      --tile-down: #1a2a43;
      --tile-border: #385081;
      --flag: #ff6b6b;
      --shadow: rgba(0, 0, 0, 0.7);
      background: var(--bg);
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s ease;
    }
    .window{width:100%;max-width:820px;background:var(--panel);border-radius:12px;box-shadow:0 12px 30px var(--shadow);overflow:hidden;display:flex;flex-direction:column}
    .titlebar{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:linear-gradient(90deg,var(--accent),#0a4aa3);color:#fff;font-size:18px;font-weight:700}
    .toolbar{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(0,0,0,0.06);flex-wrap:wrap}
    .status{display:flex;gap:12px;align-items:center}
    .digit{width:84px;height:56px;background:#000;color:#ff0000;font-family:monospace;font-weight:700;display:flex;align-items:center;justify-content:center;border-radius:10px;font-size:32px}
    .smiley{width:54px;height:54px;border-radius:10px;background:var(--face);display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;box-shadow:0 4px 8px var(--shadow)}
    .controls{display:flex;gap:8px;align-items:center;margin-left:auto}
    .board-wrap{padding:16px;display:flex;justify-content:center;flex:1;overflow:auto}
    .board{display:grid;grid-gap:6px;background:var(--tile-border);padding:12px;border-radius:12px}
    .cell{width:var(--cell-size);height:var(--cell-size);background:var(--tile);display:flex;align-items:center;justify-content:center;font-weight:700;user-select:none;cursor:pointer;border-radius:8px;font-size:20px;box-shadow:inset 0 3px 6px rgba(255,255,255,0.6), inset 0 -3px 6px rgba(0,0,0,0.12)}
    .cell.revealed{background:var(--tile-down);box-shadow:none;cursor:default}
    .cell.flagged{color:var(--flag)}
    .cell.mine{background:#ffdddd}
    /* cheat highlight (toggle with Ctrl+Shift+M) */
    .cell.cheat{
      /* glowing highlight around the cell */
      box-shadow: 0 0 0 3px rgba(255,80,80,0.18), inset 0 3px 8px rgba(255,80,80,0.06);
      transform: scale(1.02);
      transition: box-shadow 0.18s ease, transform 0.12s ease;
      z-index: 2;
    }
    button,select{padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);background:transparent;cursor:pointer}
    .footer{font-size:14px;color:var(--text);padding:12px;border-top:1px solid rgba(0,0,0,0.06);text-align:center}
    .n1{color:#0645ad}.n2{color:#0b8a2b}.n3{color:#c03228}.n4{color:#2b2b8f}.n5{color:#8a2b2b}.n6{color:#1a8a8a}.n7{color:#000}.n8{color:#666}
    .stats{padding:12px;border-top:1px solid rgba(0,0,0,0.04);display:flex;gap:16px;justify-content:center;flex-wrap:wrap;background:linear-gradient(180deg, rgba(0,0,0,0.01), transparent)}
    @media (max-width:520px){:root{--cell-size:34px} .digit{width:64px;height:44px;font-size:22px}}
  </style>
</head>
<body>
  <div class="window" role="application" aria-label="Minesweeper modern">
    <div class="titlebar">
      <div>Minesweeper</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="resetBtn" title="New game">üîÅ</button>
        <button id="themeToggle" title="Toggle theme">üåô</button>
      </div>
    </div>
    <div class="toolbar">
      <div class="status">
        <div id="mineCounter" class="digit" aria-live="polite">000</div>
        <div id="smiley" class="smiley" title="New Game">üôÇ</div>
        <div id="timer" class="digit" aria-live="polite">000</div>
      </div>

      <div class="controls">
        <label for="size">Preset</label>
        <select id="size">
          <option value="9,9,10">Beginner (9√ó9)</option>
          <option value="16,16,40">Intermediate (16√ó16)</option>
          <option value="30,16,99">Expert (30√ó16)</option>
        </select>
        <button id="flagToggle" title="Flag mode">üö© Flag</button>
      </div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" tabindex="0" aria-label="Minesweeper board"></div>
    </div>

    <div class="stats">
      Beginner Wins: <strong id="statBeginner">0</strong>
      Intermediate Wins: <strong id="statIntermediate">0</strong>
      Expert Wins: <strong id="statExpert">0</strong>
    </div>

    <div class="footer">Left-click reveal ‚Ä¢ Right-click flag ‚Ä¢ Long-press (mobile) to flag ‚Ä¢ Double-click/middle-click to chord</div>
  </div>

<script>
(() => {
  const boardEl = document.getElementById('board');
  const mineCounter = document.getElementById('mineCounter');
  const timerEl = document.getElementById('timer');
  const smiley = document.getElementById('smiley');
  const sizeSelect = document.getElementById('size');
  const flagToggle = document.getElementById('flagToggle');
  const resetBtn = document.getElementById('resetBtn');
  const themeToggle = document.getElementById('themeToggle');

  let wins = { beginner: 0, intermediate: 0, expert: 0 };
  if (localStorage.getItem('wins')) {
    try { wins = JSON.parse(localStorage.getItem('wins')); } catch(e){}
  }
  function saveWins(){ localStorage.setItem('wins', JSON.stringify(wins)); }
  function updateWinsUI(){ 
    document.getElementById('statBeginner').textContent = wins.beginner; 
    document.getElementById('statIntermediate').textContent = wins.intermediate; 
    document.getElementById('statExpert').textContent = wins.expert; 
  }
  updateWinsUI();

  let dark = localStorage.getItem('theme')==='dark';
  if(dark) {
    document.documentElement.classList.add('dark');
    document.body.classList.add('dark');
  }
  themeToggle.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
  themeToggle.addEventListener('click', ()=>{
    dark = !dark;
    document.documentElement.classList.toggle('dark', dark);
    document.body.classList.toggle('dark', dark);
    localStorage.setItem('theme', dark?'dark':'light');
    themeToggle.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
  });

  let rows = 9, cols = 9, mines = 10;
  let grid = [];
  let started = false;        // indicates timer has started (user's first real click)
  let minesPlaced = false;    // indicates mines have been placed on the grid
  let gameOver = false;
  let timerId = null, seconds = 0;
  let flagsLeft = mines;
  let flagMode = false;
  let cheatActive = false;    // whether cheat highlight is active

  function setDigits(el, n){ el.textContent = String(Math.max(0, n)).padStart(3,'0'); }
  function cellIndex(r,c){ return r*cols + c; }
  function inBounds(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }

  function createGrid(){
    grid = new Array(rows*cols).fill(null).map((_,i)=>({
      index:i,
      r: Math.floor(i/cols),
      c: i%cols,
      mine:false,
      adj:0,
      revealed:false,
      flagged:false,
      el:null
    }));
  }

  function buildBoard(){
    boardEl.innerHTML = '';
    boardEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    boardEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;

    grid.forEach(cell => {
      const el = document.createElement('div');
      el.className = 'cell';
      el.dataset.index = cell.index;
      el.setAttribute('role','button');
      el.setAttribute('aria-label', `Cell ${cell.r+1},${cell.c+1}`);
      cell.el = el;
      boardEl.appendChild(el);

      el.addEventListener('click', (ev)=>{ ev.preventDefault(); handlePrimary(cell.index); });
      el.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); handleFlag(cell.index); });
      el.addEventListener('auxclick', (ev)=>{ if(ev.button===1){ ev.preventDefault(); chord(cell.index); } });
      el.addEventListener('dblclick', (ev)=>{ ev.preventDefault(); chord(cell.index); });

      let touchTimer = null;
      el.addEventListener('touchstart', (ev)=>{
        if(gameOver) return;
        touchTimer = setTimeout(()=>{ handleFlag(cell.index); touchTimer = null; }, 600);
      }, {passive:true});
      el.addEventListener('touchend', (ev)=>{
        if(touchTimer){ clearTimeout(touchTimer); touchTimer = null; handlePrimary(cell.index); }
      });

      el.tabIndex = 0;
      el.addEventListener('keydown', (ev)=>{
        if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); handlePrimary(cell.index); }
        if(ev.key.toLowerCase()==='f'){ ev.preventDefault(); handleFlag(cell.index); }
      });
    });
  }

  function neighbors(i){
    const r = grid[i].r, c = grid[i].c;
    const out = [];
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      if(dr===0 && dc===0) continue;
      const nr=r+dr, nc=c+dc;
      if(inBounds(nr,nc)) out.push(cellIndex(nr,nc));
    }
    return out;
  }

  function placeMines(firstIndex){
    const banned = new Set([firstIndex, ...neighbors(firstIndex)]);
    let placed = 0;
    while(placed < mines){
      const i = Math.floor(Math.random()*grid.length);
      if(grid[i].mine) continue;
      if(banned.has(i)) continue;
      grid[i].mine = true; placed++;
    }
    grid.forEach((cell, idx)=>{
      if(cell.mine){ cell.adj = -1; return; }
      cell.adj = neighbors(idx).reduce((s,n)=> s + (grid[n].mine?1:0), 0);
    });
    minesPlaced = true;
  }

  function startTimer(){ if(timerId) return; timerId = setInterval(()=>{ seconds++; setDigits(timerEl, Math.min(seconds,999)); }, 1000); }
  function stopTimer(){ if(timerId) clearInterval(timerId); timerId = null; }

  function resetState(){ started = false; minesPlaced = false; gameOver = false; seconds = 0; stopTimer(); setDigits(timerEl, 0); }

  function renderCell(cell){
    const el = cell.el;
    // keep 'cheat' class intact so highlights persist while needed
    el.classList.remove('revealed','flagged','mine');
    el.textContent = '';
    if(cell.revealed){
      el.classList.add('revealed');
      if(cell.mine){ el.textContent = 'üí£'; el.classList.add('mine'); }
      else if(cell.adj>0){ el.textContent = cell.adj; el.classList.add('n'+cell.adj); }
    } else if(cell.flagged){
      el.textContent = '‚öë'; el.classList.add('flagged');
    } else {
      el.textContent = '';
    }
  }

  function revealFlood(startIdx){
    const stack = [startIdx];
    while(stack.length){
      const i = stack.pop();
      const cell = grid[i];
      if(cell.revealed || cell.flagged) continue;
      cell.revealed = true;
      renderCell(cell);
      if(!cell.mine) revealedCount++;
      if(cell.adj === 0){ neighbors(i).forEach(n=>{ if(!grid[n].revealed && !grid[n].mine) stack.push(n); }); }
    }
  }

  let revealedCount = 0;

  function handlePrimary(index){
    if(gameOver) return;
    const cell = grid[index];
    if(flagMode){ handleFlag(index); return; }
    // ensure mines exist (place them on first real click if not already placed)
    if(!minesPlaced){
      placeMines(index);
    }
    // start the timer on the first real click
    if(!started){
      started = true;
      startTimer();
    }
    if(cell.flagged || cell.revealed) return;
    if(cell.mine){
      cell.revealed = true; renderCell(cell);
      endGame(false, index);
      return;
    }
    revealFlood(index);
    checkWin();
  }

  function handleFlag(index){
    if(gameOver) return;
    const cell = grid[index];
    if(cell.revealed) return;
    cell.flagged = !cell.flagged;
    renderCell(cell);
    flagsLeft += cell.flagged ? -1 : 1;
    setDigits(mineCounter, flagsLeft);
  }

  function chord(index){
    if(gameOver) return;
    const cell = grid[index];
    if(!cell.revealed || cell.adj<=0) return;
    const neigh = neighbors(index);
    const flagged = neigh.reduce((s,n)=> s + (grid[n].flagged?1:0), 0);
    if(flagged === cell.adj){
      neigh.forEach(n => { if(!grid[n].flagged && !grid[n].revealed) handlePrimary(n); });
    }
  }

  function revealAllMines(triggerIdx){
    grid.forEach((cell, idx)=>{
      if(cell.mine){ cell.revealed = true; renderCell(cell); }
      else if(cell.flagged && !cell.mine){ cell.el.textContent = '‚úñ'; cell.el.classList.add('revealed'); }
    });
    if(typeof triggerIdx === 'number'){ grid[triggerIdx].el.classList.add('mine', 'revealed'); }
  }

  function endGame(win, triggerIdx){
    gameOver = true; stopTimer();
    if(win){
      grid.forEach(cell=>{ if(cell.mine && !cell.flagged){ cell.flagged = true; renderCell(cell); } });
      const preset = sizeSelect.selectedIndex;
      if(preset===0) wins.beginner++;
      else if(preset===1) wins.intermediate++;
      else wins.expert++;
      saveWins(); updateWinsUI();
      setTimeout(()=> alert('You win!'), 80);
    } else {
      revealAllMines(triggerIdx);
      setTimeout(()=> alert('Game over!'), 80);
    }
  }

  function checkWin(){
    if(revealedCount === rows*cols - mines){ endGame(true); }
  }

  function newGame(c=cols, r=rows, m=mines){
    cols = c; rows = r; mines = m;
    flagsLeft = mines; setDigits(mineCounter, flagsLeft);
    createGrid(); buildBoard(); revealedCount = 0; resetState();
    cheatActive = false;
    smiley.textContent = 'üôÇ';
    grid.forEach(cell => renderCell(cell));
  }

  sizeSelect.addEventListener('change', ()=>{
    const [c, r, m] = sizeSelect.value.split(',').map(Number);
    newGame(c, r, m);
  });
  resetBtn.addEventListener('click', ()=>{ newGame(cols, rows, mines); smiley.textContent='üôÇ'; });
  smiley.addEventListener('click', ()=>{ newGame(cols, rows, mines); smiley.textContent='üôÇ'; });
  flagToggle.addEventListener('click', ()=>{ 
    flagMode = !flagMode; 
    flagToggle.textContent = flagMode ? 'üö© Flag ‚úì' : 'üö© Flag'; 
  });

  document.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){
      e.preventDefault();
      flagMode = !flagMode;
      flagToggle.textContent = flagMode ? 'üö© Flag ‚úì' : 'üö© Flag';
    }
  });

  // === CHEAT: toggle highlight for bombs (Ctrl+Shift+M) ===
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.code === 'KeyM') {
      e.preventDefault();
      cheatActive = !cheatActive;

      // If bombs haven't been placed yet, place them quietly (use center index as seed)
      if(!minesPlaced){
        const seedIndex = Math.floor((rows*cols)/2);
        placeMines(seedIndex);
        // don't start timer here; started remains false until player's click
      }

      // Toggle the visual highlight class on actual mine cells
      grid.forEach(cell => {
        if(cell.mine && cell.el){
          cell.el.classList.toggle('cheat', cheatActive);
        }
      });

      // give a visual cue on smiley
      smiley.textContent = cheatActive ? 'üòé' : 'üôÇ';
    }
  });
  // =======================================================

  setDigits(timerEl, 0);
  setDigits(mineCounter, mines);
  newGame();
})();
</script>
</body>
</html>
